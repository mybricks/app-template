// @ts-check
const fs = require('fs')
const pt = require('path')
const Webpack = require('webpack')
const portfinder = require('portfinder')
const WebpackDevServer = require('webpack-dev-server')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const ExtraWatchWebpackPlugin = require('extra-watch-webpack-plugin')

const {
  opIsArray,
  initEditJS,
  getEntryCfg,
  scanComJson,
  getNodeType,
  initRuntimeJS
} = require('./utils') 

const temporaryPath = pt.resolve(__dirname, 'temporary')

if (!fs.existsSync(temporaryPath)) {
  fs.mkdirSync(temporaryPath);
}

const _templateAssetRegExp = ext => new RegExp(`(.+?)\\.${ext}$`, 'i')
	
let templateAssetRegExp = _templateAssetRegExp('html')

module.exports = class MybricksPluginConnectComlibApp {

  ready = false
  url = ''

  constructor(options = {}) {
    const { path, useTest = true } = options

    if (!path) {
      throw new Error('缺少 path(组件库*.mybricks.json绝对路径) 配置')
    }
    this.options = options
    const configPath = path
    const docPath = pt.resolve(path, '../')
    const pkgPath = pt.resolve(path, '../package.json')
    const entryCfg = getEntryCfg(pkgPath, configPath)
    let comlibPath = 'comAry'
    let { comAry, externals } = entryCfg
    let type = getNodeType(comAry)

    if (type !== 'array') {
      if (type === 'object') {
        const { test, publish } = comAry
  
        if (opIsArray(test) && useTest) {
          comAry = test
          comlibPath = comlibPath + '.test'
        } else if (opIsArray(publish)) {
          comAry = publish
          comlibPath = comlibPath + '.publish'
        }
      }
    }

    let editJS = initEditJS(entryCfg)
    let rtJS = initRuntimeJS(entryCfg)

    const { editJS: comEditJS, singleComs, rtJS: comRtJS } = scanComJson(docPath, comAry)

    editJS = editJS + comEditJS + 'document.head.appendChild = _headAppendChild;';
    rtJS = rtJS + comRtJS

    const id = entryCfg.libName.replace(/@|\//gi, '_') + '.js'
    const editJSPath = pt.join(temporaryPath, id)

    fs.writeFileSync(editJSPath, editJS)

    const extraWatchFiles = singleComs.map(({comJsonPath}) => comJsonPath)

    const watchFilesMap = {};

    extraWatchFiles.forEach(file => {
      watchFilesMap[file] = true;
    });

    this.watchFilesMap = watchFilesMap

    const externalsMap = {
      'react': {
        commonjs: 'react',
        commonjs2: 'react',
        amd: 'react',
        root: 'React',
      },
      'react-dom': {
        commonjs: 'react-dom',
        commonjs2: 'react-dom',
        amd: 'react-dom',
        root: 'ReactDOM',
      },
    }

    if (opIsArray(externals)) {
      externals.forEach(({name, library}) => {
        externalsMap[name] = library
      })
    }

    const webpackConfig = {
      mode: 'development',
      entry: editJSPath,
      output: {
        // path: outputPath,
        filename: 'comlib.js',
        libraryTarget: 'umd',
        library: 'comlib'
      },
      stats: {
        colors: true,
        preset: 'normal'
      },
      resolve: {
        alias: {},
        extensions: ['.js', '.jsx', '.ts', '.tsx'],
      },
      externals: [externalsMap],
      module: {
        rules: [
          {
            test: /\.jsx?$/,
            use: [
              {
                loader: 'babel-loader',
                options: {
                  presets: [
                    '@babel/preset-react'
                  ],
                  plugins: [
                    ['@babel/plugin-proposal-class-properties', {'loose': true}]
                  ],
                  cacheDirectory: true
                }
              }
            ]
          },
          {
            test: /\.tsx?$/,
            use: [
              {
                loader: 'babel-loader',
                options: {
                  presets: [
                    '@babel/preset-react'
                  ],
                  plugins: [
                    ['@babel/plugin-proposal-class-properties', {'loose': true}]
                  ],
                  cacheDirectory: true
                }
              },
              {
                loader: 'ts-loader',
                options: {
                  silent: true,
                  transpileOnly: true
                },
              },
            ],
          },
          {
            test: /\.css$/,
            use: ['style-loader', 'css-loader']
          },
          {
            test: /\.less$/i,
            use: [
              {
                loader: 'style-loader',
                options: {attributes: {title: 'less'}}
              },
              {
                loader: 'css-loader',
                options: {
                  modules: {
                    localIdentName: '[local]-[hash:5]'
                  }
                }
              },
              'less-loader'
            ]
          },
          {
            test: /\.(gif|png|jpe?g|webp|svg|woff|woff2|eot|ttf)$/i,
            use: [
              {
                loader: 'url-loader',
                options: {
                  limit: 1024 * 2,
                  name: 'img_[name]_[contenthash:4].[ext]'
                }
              }
            ]
          },
          {
            test: /\.d.ts$/i,
            use: [{ loader: 'raw-loader' }]
          },
          {
            test: /\.(xml|txt|html|cjs|theme)$/i,
            use: [{ loader: 'raw-loader' }]
          }
        ]
      },
      devtool: 'cheap-source-map',
      devServer: {
        // open: true,
        hot: true,
        allowedHosts: 'all',
        // static: {
        //   directory: outputPath,
        // },
        client: {
          logging: 'warn'
        },
        proxy: [],
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Access-Control-Allow-Methods":
              "GET, POST, PUT, DELETE, PATCH, OPTIONS",
          "Access-Control-Allow-Headers":
              "X-Requested-With, content-type, Authorization",
        },
      },
      optimization: {
        concatenateModules: false
      },
      // cache: {
      //   type: 'filesystem',
      //   name: id
      // },
      plugins: [
        new ExtraWatchWebpackPlugin({
          files: extraWatchFiles
        }),
      ]
    }

    portfinder.getPortPromise()
      .then((port) => {
        const compiler = Webpack(webpackConfig);
        const devServerOptions = { ...webpackConfig.devServer, port};
        const server = new WebpackDevServer(devServerOptions, compiler);
    
        server.startCallback(() => {
          this.url = `http://localhost:${port}/comlib.js`
          this.ready = true
        });
      })
      .catch((err) => {
        throw new Error(err)
      })
  }

  apply(compiler) {
    const that = this

    compiler.hooks.emit.tapAsync(
      'MybricksPluginConnectComlibAppEmit',
      (compilation, callback) => {

        if (that.ready) {
          Done()
        } else {
          let time = setInterval(() => {
            if (that.ready) {
              clearInterval(time)
              time = null
              Done()
            }
          }, 500)
        }

        function Done () {

          
          const assets = compilation.assets
          const assetsNames = Object.keys(assets)

          
          let lookupAsset = 0, lookupAssetName

          for (let v = 0; v < assetsNames.length; ++v) {
            if (templateAssetRegExp.test(lookupAssetName = assetsNames[v])) {
              lookupAsset = assets[lookupAssetName]
              break
            }
          }

          if (lookupAsset) {
            let lookupAssetSource = lookupAsset.source()

            lookupAssetSource = lookupAssetSource.replace('</head>', `\n<script src="${that.url}"></script>\n</head>`)
  
            if (compilation.getAsset(lookupAssetName)) {
              compilation.updateAsset(lookupAssetName, new Webpack.sources.RawSource(lookupAssetSource))
            } else {
              compilation.emitAsset(lookupAssetName, new Webpack.sources.RawSource(lookupAssetSource))
            }
  
            // assets[lookupAssetName] = {
            //   source: () => lookupAssetSource,
            //   size: () => lookupAssetSource.length
            // }  
          } else {
            const assetsDirs = fs.readdirSync(compilation.outputOptions.path)

            assetsDirs.forEach((file) => {
              if (templateAssetRegExp.test(file)) {
                let lookupAssetSource = fs.readFileSync(pt.resolve(compilation.outputOptions.path, `./${file}`), 'utf-8')
                lookupAssetSource = lookupAssetSource.replace('</head>', `\n<script src="${that.url}"></script>\n</head>`)
                // assets[file] = {
                //   source: () => lookupAssetSource,
                //   size: () => lookupAssetSource.length
                // }
                if (compilation.getAsset(file)) {
                  compilation.updateAsset(file, new Webpack.sources.RawSource(lookupAssetSource))
                } else {
                  compilation.fileDependencies.add(pt.resolve(compilation.outputOptions.path, file));
                
                  compilation.emitAsset(file, new Webpack.sources.RawSource(lookupAssetSource))
                }
              }
            })
          }

         
          callback()
        }
      }
    )

    compiler.hooks.watchRun.tap(
      'MybricksPluginConnectComlibAppWatchRun',
      (compilation) => {
        let changedFiles = [];

        if (compilation.modifiedFiles) {
          changedFiles = Array.from(compilation.modifiedFiles);
        }

        const watchFilesMap = that.watchFilesMap

        const hasComJsonFile = changedFiles.some((file) => {
          return watchFilesMap[file];
        });

        if (hasComJsonFile) {
          
        }
    })
  }
}
